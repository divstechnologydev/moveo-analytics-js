(function (window) {
  // Prevent multiple initializations
  if (window.MoveoOne) return;

  const API_URL = "https://dev-api.moveo.one/api/analytic/event/tag";

  /**
   * Core MoveoOne Web Tracker
   */
  class MoveoOneWeb {
    constructor(token) {
      this.token = token;
      this.userId = "";
      this.buffer = [];
      this.flushInterval = 5000;
      this.maxThreshold = 500;
      this.context = "WEB_STATIC";

      // Use persistent session ID across page loads
      this.sessionId = this.getOrCreateSessionId();
      this.started = false;
      this.pendingUpdates = []; // Queue for updates before session starts

      // Predefined meta fields (optional, no defaults)
      this.meta = {};

      // Additional metadata - flexible key-value pairs
      this.additionalMeta = {};

      // Track viewport size for resize events
      this.currentViewport = {
        width: window.innerWidth,
        height: window.innerHeight,
      };

      // Check if this is a page navigation within existing session
      this.isPageNavigation = this.checkIfPageNavigation();

      // Impression tracking state
      this.impressionObserver = null;
      this.seenElements = new WeakSet();

      // Start flush interval
      setInterval(() => this.flush(), this.flushInterval);
    }

    // Get existing session ID or create new one
    getOrCreateSessionId() {
      const storageKey = "moveo-session-id";
      const timestampKey = "moveo-session-timestamp";
      const sessionTimeout = 30 * 60 * 1000; // 30 minutes in milliseconds

      const existingSessionId = localStorage.getItem(storageKey);
      const sessionTimestamp = localStorage.getItem(timestampKey);

      // Check if existing session is still valid
      if (existingSessionId && sessionTimestamp) {
        const now = Date.now();
        const lastActivity = parseInt(sessionTimestamp, 10);

        if (now - lastActivity < sessionTimeout) {
          // Update timestamp for current activity
          localStorage.setItem(timestampKey, now.toString());
          return existingSessionId;
        }
      }

      // Create new session
      const newSessionId = this.generateUUID();
      localStorage.setItem(storageKey, newSessionId);
      localStorage.setItem(timestampKey, Date.now().toString());

      return newSessionId;
    }

    // Check if this is a page navigation within an existing session
    checkIfPageNavigation() {
      const lastPathKey = "moveo-last-path";
      const lastPath = localStorage.getItem(lastPathKey);
      const currentPath = window.location.pathname;

      // Store current path for next page load
      localStorage.setItem(lastPathKey, currentPath);

      // If we have a last path and it's different from current, it's navigation
      return lastPath && lastPath !== currentPath;
    }

    // Update session timestamp on activity
    updateSessionActivity() {
      const timestampKey = "moveo-session-timestamp";
      localStorage.setItem(timestampKey, Date.now().toString());
    }

    initialize() {
      // Start session asynchronously without blocking
      this.start();

      // Setup event listeners immediately
      this.setupClickTracking();
      this.setupDownloadOrOutboundLinkTracking();
      this.setupScrollTracking();
      this.setupFormTracking();
      this.setupHoverTracking();
      this.setupResizeTracking();
      this.setupPageUnloadTracking();
      this.setupMediaTracking();
      this.setupClipboardTracking();
    }

    identify(userId) {
      this.userId = userId;
    }

    // Methods to update predefined meta fields (only locale, test, softwareVersion)
    setLocale(locale) {
      this.meta.locale = locale;
      this.queueOrSendUpdate("meta");
    }

    setTest(test) {
      this.meta.test = test;
      this.queueOrSendUpdate("meta");
    }

    setSoftwareVersion(version) {
      this.meta.softwareVersion = version;
      this.queueOrSendUpdate("meta");
    }

    // Helper method to queue updates before session starts or send immediately
    queueOrSendUpdate(type) {
      if (this.started) {
        // Session already started, send update immediately
        if (type === "meta") {
          this.addUpdateMetadataEvent();
        } else if (type === "additional") {
          this.addUpdateAdditionalMetadataEvent();
        }
      } else {
        // Session not started yet, queue the update
        this.pendingUpdates.push(type);
      }
    }

    // Process all pending updates after session starts
    processPendingUpdates() {
      const uniqueUpdates = [...new Set(this.pendingUpdates)]; // Remove duplicates

      uniqueUpdates.forEach((type) => {
        if (type === "meta") {
          this.addUpdateMetadataEvent();
        } else if (type === "additional") {
          this.addUpdateAdditionalMetadataEvent();
        }
      });

      this.pendingUpdates = []; // Clear the queue
    }

    // Helper method to add update_metadata event to buffer
    addUpdateMetadataEvent() {
      const event = {
        c: this.context,
        type: "update_metadata",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMeta: { ...this.additionalMeta },
        sId: this.sessionId,
      };

      this.buffer.push(event);
      this.flushOrRecord(false);
    }

    // Method to update additional metadata (flexible key-value)
    updateAdditionalMetadata(additionalData) {
      this.additionalMeta = {
        ...this.additionalMeta,
        ...additionalData,
      };

      this.queueOrSendUpdate("additional");
    }

    // Helper method to add update_additional_metadata event to buffer
    addUpdateAdditionalMetadataEvent() {
      const event = {
        c: this.context,
        type: "update_additional_metadata",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMeta: { ...this.additionalMeta },
        sId: this.sessionId,
      };

      this.buffer.push(event);
      this.flushOrRecord(false);
    }

    // Legacy method - now only updates additionalMeta
    updateMetadata(metadata) {
      this.updateAdditionalMetadata(metadata);
    }

    // Helper method
    flushOrRecord(force = false) {
      if (force || this.buffer.length >= this.maxThreshold) {
        this.flush();
      }
    }

    track(type, data) {
      // Update session activity on any tracking event
      this.updateSessionActivity();

      const event = {
        c: this.context,
        type: "track",
        userId: this.userId,
        t: Date.now(),
        prop: {
          sg: window.location.pathname || "unknown",
          eID: data.id,
          eA: data.action,
          eT: data.type,
          eV: data.value || "",
        },
        sId: this.sessionId,
      };

      this.buffer.push(event);

      if (this.buffer.length >= this.maxThreshold) {
        this.flush();
      }
    }

    // Immediate track method for critical events (like downloads and outbound links)
    trackImmediate(type, data) {
      // Update session activity
      this.updateSessionActivity();

      const event = {
        c: this.context,
        type: "track",
        userId: this.userId,
        t: Date.now(),
        prop: {
          sg: window.location.pathname || "unknown",
          eID: data.id,
          eA: data.action,
          eT: data.type,
          eV: data.value || "",
        },
        sId: this.sessionId,
      };

      // Merge any event-specific metadata into additionalMeta
      if (data.metadata) {
        event.additionalMeta = {
          ...event.additionalMeta,
          ...data.metadata,
        };
      }

      // Send immediately using sendBeacon for reliability
      this.sendEventImmediate(event);
    }

    // Send single event immediately using fetch with keepalive
    sendEventImmediate(event) {
      const data = JSON.stringify({ events: [event] });

      // Use fetch with keepalive instead of sendBeacon to maintain headers
      fetch(API_URL, {
        method: "POST",
        headers: {
          Authorization: this.token,
          "Content-Type": "application/json",
        },
        body: data,
        keepalive: true, // Ensures request completes even if page unloads
      }).catch((error) => console.error("MoveoOne Immediate Error:", error));
    }

    enrichWithGeolocation() {
      return fetch("https://ipapi.co/json/")
        .then((response) => response.json())
        .then((location) => ({
          // only the country name, as a string
          location: location.country_name || "",
        }))
        .catch((err) => {
          console.warn("MoveoOne: Failed to enrich geolocation", err);
          return { location: "" };
        });
    }

    async start() {
      // If this is a page navigation, send page_navigation event instead of start_session
      if (this.isPageNavigation) {
        await this.trackPageNavigation();
        this.started = true;
        this.processPendingUpdates();
        // Initialize impression tracking after session is started
        this.initImpressionObserver();
        return;
      }

      // This is a new session
      const event = {
        c: this.context,
        type: "start_session",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMeta: { ...this.additionalMeta },
        sId: this.sessionId,
      };

      // Extract UTM parameters
      const params = new URLSearchParams(window.location.search);
      const utmParams = {
        utm_source: params.get("utm_source") || "",
        utm_medium: params.get("utm_medium") || "",
        utm_campaign: params.get("utm_campaign") || "",
        utm_term: params.get("utm_term") || "",
        utm_content: params.get("utm_content") || "",
      };

      // Check returning visitor status and add to additionalMeta
      const isReturning = localStorage.getItem("moveo-returning") === "true";

      if (!isReturning) {
        localStorage.setItem("moveo-returning", "true");
      }

      // All session data goes to additionalMeta
      const sessionData = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language || navigator.userLanguage,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        referrer: document.referrer || "",
        returningVisitor: isReturning,
      };

      // Screen and viewport information
      const screenData = {
        screenWidth: window.screen.width,
        screenHeight: window.screen.height,
        screenColorDepth: window.screen.colorDepth,
        viewportWidth: window.innerWidth,
        viewportHeight: window.innerHeight,
        devicePixelRatio: window.devicePixelRatio || 1,
      };

      // Get geolocation data asynchronously (this is the slow part)
      const geoData = await this.enrichWithGeolocation();

      // Add all additional data to additionalMeta
      event.additionalMeta = {
        ...event.additionalMeta,
        ...utmParams,
        ...sessionData,
        ...screenData,
        ...geoData,
        url: window.location.href,
        title: document.title,
      };

      // Update instance additionalMeta
      this.additionalMeta = {
        ...this.additionalMeta,
        ...event.additionalMeta,
      };

      this.buffer.push(event);
      this.started = true; // Set started to true after adding start_session event

      // Process any pending updates that were queued before session started
      this.processPendingUpdates();

      // Flush the start_session event first
      this.flush();

      // Track initial page view
      this.track("page_view", {
        semanticGroup: window.location.pathname || "unknown",
        id: window.location.pathname,
        type: "page",
        action: "view",
        value: document.title,
      });

      // Initialize impression tracking after session is started and flushed
      setTimeout(() => {
        this.initImpressionObserver();
      }, 100);
    }

    // New method for auto-discovery impression tracking
    initImpressionObserver() {
      if (!this.started) return; // Don't start until session is established

      // Configuration
      const SELECTORS = [
        "img[src]",
        "video",
        'iframe[src*="youtube"], iframe[src*="vimeo"]',
        'a[href]:not([href="#"])',
        'button, input[type=button i], input[type=submit i], [role="button"]',
        "h1, h2, h3",
      ];
      const TEXT_LEN_MIN = 35;
      const IO_THRESHOLD = 0.2; // 20% visible

      // Internals
      const schedule = (() => {
        let id;
        return (fn) => {
          cancelAnimationFrame(id);
          id = requestAnimationFrame(fn);
        };
      })();

      // Create intersection observer for appear events
      this.impressionObserver = new IntersectionObserver(
        (entries) => {
          schedule(() => {
            entries.forEach((e) => {
              if (e.isIntersecting && !this.seenElements.has(e.target)) {
                this.seenElements.add(e.target);
                this.sendAutoImpression(
                  e.target,
                  e.boundingClientRect,
                  "appear"
                );
              } else if (!e.isIntersecting && this.seenElements.has(e.target)) {
                this.sendAutoImpression(
                  e.target,
                  e.boundingClientRect,
                  "disappear"
                );
              }
            });
          });
        },
        { root: null, threshold: IO_THRESHOLD }
      );

      // Discovery helpers
      const qualifiesTextBlock = (el) => {
        if (!el.childNodes.length) return false;
        return [...el.childNodes].some(
          (n) => n.nodeType === 3 && n.textContent.trim().length >= TEXT_LEN_MIN
        );
      };

      const addIfInteresting = (el) => {
        if (!el || el.nodeType !== 1) return; // Only element nodes

        // Skip elements that are already being observed
        if (el.dataset && el.dataset.moveoObserved) return;

        const matchesCSS = el.matches && el.matches(SELECTORS.join(","));
        if (matchesCSS || qualifiesTextBlock(el)) {
          this.impressionObserver.observe(el);
          el.dataset.moveoObserved = "true";
        }
      };

      // Initial DOM sweep - wait for DOM to be ready
      const performInitialScan = () => {
        document.querySelectorAll("*").forEach(addIfInteresting);
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", performInitialScan);
      } else {
        performInitialScan();
      }

      // SPA / lazy-load support: watch for new nodes
      const mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType !== 1) return;
            addIfInteresting(node);
            if (node.querySelectorAll) {
              node.querySelectorAll("*").forEach(addIfInteresting);
            }
          });
        });
      });

      mutationObserver.observe(document.documentElement, {
        childList: true,
        subtree: true,
      });
    }

    sendAutoImpression(el, rect, action) {
      // Determine the element value based on type
      let value = "";

      if (el.matches("img")) {
        // For images, use alt text, title, or fallback to src filename
        value =
          el.alt ||
          el.title ||
          this.getFilenameFromUrl(el.currentSrc || el.src) ||
          "image";
      } else if (el.matches("video")) {
        // For videos, use title or fallback to src filename
        value =
          el.title ||
          this.getFilenameFromUrl(el.currentSrc || el.src) ||
          "video";
      } else if (el.matches("iframe")) {
        // For iframes (YouTube, Vimeo), use title or extract from src
        value =
          el.title || this.getFilenameFromUrl(el.src) || "embedded_content";
      } else if (el.matches("a")) {
        // For links, use the link text or href if no text
        value =
          (el.innerText || el.textContent || "").trim() || el.href || "link";
      } else if (el.matches('button,input,[role="button"]')) {
        // For buttons, use text content, value, or aria-label
        value =
          (
            el.innerText ||
            el.value ||
            el.getAttribute("aria-label") ||
            ""
          ).trim() || "button";
      } else if (el.matches("h1,h2,h3")) {
        // For headings, use the text content
        value = (el.innerText || el.textContent || "").trim() || "heading";
      } else {
        // For text elements, use the text content
        value = (el.innerText || el.textContent || "").trim() || "text";
      }

      // Limit value length to prevent overly long strings
      if (value.length > 100) {
        value = value.substring(0, 97) + "...";
      }

      // Create impression event with proper structure
      const data = {
        semanticGroup: window.location.pathname || "unknown",
        id:
          el.id || el.className || `${el.tagName.toLowerCase()}_${Date.now()}`,
        type: el.tagName.toLowerCase(), // HTML tag name as type
        action: action, // 'appear' or 'disappear'
        value: value, // The actual content (text/alt/href)
      };

      this.track("impression", data);
    }

    // Helper method to extract filename from URL
    getFilenameFromUrl(url) {
      if (!url) return "";
      try {
        const pathname = new URL(url).pathname;
        const filename = pathname.split("/").pop();
        return filename || "";
      } catch (e) {
        // If URL parsing fails, try to extract filename directly
        const parts = url.split("/");
        return parts[parts.length - 1] || "";
      }
    }

    // Helper to clean URLs (remove query params for privacy)
    cleanUrl(url) {
      if (!url) return "";
      try {
        const urlObj = new URL(url);
        return urlObj.origin + urlObj.pathname;
      } catch (e) {
        return url;
      }
    }

    // Helper method to get meaningful text content from an element
    getElementText(element) {
      // For form elements, get their value or placeholder
      if (element.tagName === "INPUT") {
        return element.value || element.placeholder || element.type;
      }
      if (element.tagName === "SELECT") {
        const selected = element.selectedOptions[0];
        return selected
          ? selected.textContent.trim()
          : element.name || "select";
      }
      if (element.tagName === "TEXTAREA") {
        return element.value || element.placeholder || "textarea";
      }

      // For images, get alt text
      if (element.tagName === "IMG") {
        return element.alt || element.title || "image";
      }

      // For other elements, get direct text content (not including children)
      let text = "";
      for (let child of element.childNodes) {
        if (child.nodeType === Node.TEXT_NODE) {
          text += child.textContent;
        }
      }

      // If no direct text, fall back to full textContent but limit it
      if (!text.trim() && element.textContent) {
        text = element.textContent.trim();
      }

      // Clean and limit the text
      text = text.trim().replace(/\s+/g, " ");
      return text.length > 100 ? text.substring(0, 97) + "..." : text;
    }

    // Helper method to determine if an element should be tracked
    shouldTrackElement(element) {
      // Skip if element is not visible
      const rect = element.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return false;

      // Skip script, style, and other non-visible elements
      const skipTags = [
        "SCRIPT",
        "STYLE",
        "NOSCRIPT",
        "META",
        "LINK",
        "HEAD",
        "TITLE",
      ];
      if (skipTags.includes(element.tagName)) return false;

      // Skip if element has no meaningful content
      const text = this.getElementText(element);
      if (!text || text.length < 2) return false;

      // Skip if element is part of tracking infrastructure
      if (element.id && element.id.includes("moveo")) return false;
      if (element.className && element.className.includes("moveo"))
        return false;

      return true;
    }

    // Enhanced hover tracking for all elements with text
    setupHoverTracking() {
      let hoverTimeout;
      const HOVER_DELAY = 1500; // Track hovers that last at least 1.5 seconds

      document.addEventListener("mouseover", (event) => {
        const target = event.target;

        // Clear any existing hover timeout
        clearTimeout(hoverTimeout);

        // Check if we should track this element
        if (!this.shouldTrackElement(target)) return;

        // Set timeout to track sustained hover
        hoverTimeout = setTimeout(() => {
          const elementText = this.getElementText(target);

          const data = {
            semanticGroup: window.location.pathname,
            id:
              target.id ||
              target.className ||
              target.tagName.toLowerCase() ||
              "unnamed_element",
            type: target.tagName.toLowerCase(),
            action: "hover",
            value: elementText,
          };

          this.track("hover", data);
        }, HOVER_DELAY);
      });

      // Clear timeout when mouse leaves
      document.addEventListener("mouseout", (event) => {
        clearTimeout(hoverTimeout);
      });
    }

    async trackPageNavigation() {
      // Track page view for the new page - send immediately to ensure proper ordering
      const event = {
        c: this.context,
        type: "track",
        userId: this.userId,
        t: Date.now(),
        prop: {
          sg: window.location.pathname || "unknown",
          eID: window.location.pathname,
          eA: "view",
          eT: "page",
          eV: document.title || "",
        },
        meta: Object.keys(this.meta).length > 0 ? { ...this.meta } : {},
        additionalMeta: { ...this.additionalMeta },
        sId: this.sessionId,
      };

      // Send page view immediately to ensure it's processed before any user interactions
      this.sendEventImmediate(event);
    }

    // Helper method to check if a URL is outbound
    isOutboundLink(url) {
      try {
        const link = new URL(url, window.location.href);
        const currentDomain = window.location.hostname;

        // Check if it's a different domain
        return (
          link.hostname !== currentDomain && link.protocol.startsWith("http")
        );
      } catch (e) {
        return false;
      }
    }

    // Updated method name and functionality
    setupDownloadOrOutboundLinkTracking() {
      // Function to track existing download and outbound links
      const trackLinks = () => {
        const links = document.querySelectorAll("a[href]");

        links.forEach((link) => {
          // Skip if already tracked
          if (link.dataset.moveoLinkTracked) return;

          const url = link.href;

          // Check if it's a downloadable file
          const isDownloadable = url.match(
            /\.(pdf|zip|docx?|xlsx?|pptx?|txt|csv|json|xml|gz|tar|rar|7z|exe|dmg|pkg|deb|rpm|iso|img|mp3|mp4|avi|mov|wmv|flv|webm|ogg|wav|flac)$/i
          );

          // Check if it's an outbound link
          const isOutbound = this.isOutboundLink(url);

          // Only track if it's either downloadable or outbound
          if (isDownloadable || isOutbound) {
            link.dataset.moveoLinkTracked = "true";

            link.addEventListener("click", (event) => {
              if (isDownloadable) {
                // Handle download tracking
                const filename = url.split("/").pop() || url;
                const fileExtension = filename.split(".").pop() || "unknown";

                this.trackImmediate("download", {
                  semanticGroup: window.location.pathname,
                  id: filename,
                  type: "download",
                  action: "click",
                  value: filename,
                });

                console.log("MoveoOne: Download tracked -", filename);
              } else if (isOutbound) {
                // Handle outbound link tracking
                const domain = new URL(url).hostname;

                this.trackImmediate("outbound_link", {
                  semanticGroup: window.location.pathname,
                  id: domain,
                  type: "outbound_link",
                  action: "click",
                  value: url,
                });

                console.log("MoveoOne: Outbound link tracked -", domain);
              }
            });
          }
        });
      };

      // Track links on initial load
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", trackLinks);
      } else {
        trackLinks();
      }

      // Watch for dynamically added links
      const setupLinkObserver = () => {
        const targetNode = document.body || document.documentElement;
        if (targetNode) {
          const observer = new MutationObserver(() => {
            trackLinks();
          });

          observer.observe(targetNode, {
            childList: true,
            subtree: true,
          });
        }
      };

      if (document.body) {
        setupLinkObserver();
      } else {
        document.addEventListener("DOMContentLoaded", setupLinkObserver);
      }
    }

    setupPageUnloadTracking() {
      // Track when user leaves the page
      window.addEventListener("beforeunload", () => {
        // Send any remaining events immediately
        if (this.buffer.length > 0) {
          // Use fetch with keepalive for reliable delivery with proper headers
          const data = JSON.stringify({ events: [...this.buffer] });
          fetch(API_URL, {
            method: "POST",
            headers: {
              Authorization: this.token,
              "Content-Type": "application/json",
            },
            body: data,
            keepalive: true,
          }).catch((error) => console.error("MoveoOne Unload Error:", error));
        }

        // Update session timestamp
        this.updateSessionActivity();
      });

      // Also track page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          this.updateSessionActivity();
          // Flush any pending events when page becomes hidden
          if (this.buffer.length > 0) {
            this.flush();
          }
        }
      });
    }

    setupMediaTracking() {
      // Track existing media elements
      const trackMediaElements = () => {
        const mediaElements = document.querySelectorAll("video, audio");

        mediaElements.forEach((media) => {
          // Avoid duplicate listeners by checking if already tracked
          if (media.dataset.moveoTracked) return;
          media.dataset.moveoTracked = "true";

          const mediaType = media.tagName.toLowerCase();
          const mediaId =
            media.id || media.currentSrc || media.src || "unnamed_media";

          media.addEventListener("play", () => {
            this.track("media_play", {
              semanticGroup: window.location.pathname,
              id: mediaId,
              type: mediaType,
              action: "play",
            });
          });

          media.addEventListener("pause", () => {
            this.track("media_pause", {
              semanticGroup: window.location.pathname,
              id: mediaId,
              type: mediaType,
              action: "pause",
            });
          });

          media.addEventListener("ended", () => {
            this.track("media_complete", {
              semanticGroup: window.location.pathname,
              id: mediaId,
              type: mediaType,
              action: "complete",
            });
          });
        });
      };

      // Track media elements on initial load
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", trackMediaElements);
      } else {
        trackMediaElements();
      }

      // Watch for dynamically added media elements
      // Only set up observer if document.body exists, otherwise wait for DOM ready
      const setupObserver = () => {
        const targetNode = document.body || document.documentElement;
        if (targetNode) {
          const observer = new MutationObserver(() => {
            trackMediaElements();
          });

          observer.observe(targetNode, {
            childList: true,
            subtree: true,
          });
        }
      };

      if (document.body) {
        setupObserver();
      } else {
        document.addEventListener("DOMContentLoaded", setupObserver);
      }
    }

    setupClipboardTracking() {
      document.addEventListener("copy", (e) => {
        const text = window.getSelection().toString();

        // Only track if there's actual text selected
        if (text && text.trim().length > 0) {
          this.track("copy", {
            semanticGroup: window.location.pathname,
            id: "copy_text",
            type: "clipboard",
            action: "copy",
            value: text.length > 100 ? text.slice(0, 100) + "â€¦" : text,
          });
        }
      });
    }

    flush() {
      if (this.buffer.length === 0) return;

      const dataToSend = [...this.buffer];
      this.buffer = [];

      // Debug logging
      console.log("MoveoOne: Sending events", dataToSend);
      dataToSend.forEach((event, index) => {
        console.log(`Event ${index}:`, {
          type: event.type,
          context: event.c,
          sessionId: event.sId,
          eA: event.prop.eA,
          eT: event.prop.eT,
          eV: event.prop.eV,
          meta: event.meta,
          additionalMeta: event.additionalMeta,
        });
      });

      fetch(API_URL, {
        method: "POST",
        headers: {
          Authorization: this.token,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ events: dataToSend }),
      }).catch((error) => console.error("MoveoOne Error:", error));
    }

    // Enhanced click tracking for all elements with text
    setupClickTracking() {
      document.addEventListener("click", (event) => {
        let target = event.target;

        // Check if we should track this element
        if (!this.shouldTrackElement(target)) return;

        // Skip download and outbound links as they're handled separately
        if (target.tagName === "A" && target.href) {
          const isDownloadable = target.href.match(
            /\.(pdf|zip|docx?|xlsx?|pptx?|txt|csv|json|xml|gz|tar|rar|7z|exe|dmg|pkg|deb|rpm|iso|img|mp3|mp4|avi|mov|wmv|flv|webm|ogg|wav|flac)$/i
          );
          const isOutbound = this.isOutboundLink(target.href);

          if (isDownloadable || isOutbound) {
            return;
          }
        }

        // Get the text content of the clicked element
        const elementText = this.getElementText(target);

        const data = {
          semanticGroup: window.location.pathname,
          id:
            target.id ||
            target.className ||
            target.tagName.toLowerCase() ||
            "unnamed_element",
          type: target.tagName.toLowerCase(),
          action: "click",
          value: elementText,
        };

        this.track("click", data);
      });
    }

    setupScrollTracking() {
      let lastScrollPosition = 0;
      let scrollTimeout;

      window.addEventListener("scroll", () => {
        clearTimeout(scrollTimeout);

        scrollTimeout = setTimeout(() => {
          const scrollPosition = window.scrollY;
          const documentHeight =
            document.documentElement.scrollHeight - window.innerHeight;
          const scrollPercentage = Math.round(
            (scrollPosition / documentHeight) * 100
          );

          if (Math.abs(scrollPosition - lastScrollPosition) > 100) {
            this.track("scroll", {
              semanticGroup: window.location.pathname,
              id: "page_scroll",
              type: "scroll",
              action: "scroll",
              value: scrollPercentage.toString(),
            });

            lastScrollPosition = scrollPosition;
          }
        }, 500);
      });
    }

    setupFormTracking() {
      document.addEventListener("submit", (event) => {
        const form = event.target;

        this.track("form_submit", {
          semanticGroup: window.location.pathname,
          id: form.id || form.name || "unnamed_form",
          type: "form",
          action: "submit",
          value: "",
        });
      });

      document.addEventListener("change", (event) => {
        const target = event.target;
        if (
          ["select", "input", "textarea"].includes(target.tagName.toLowerCase())
        ) {
          this.track("form_change", {
            semanticGroup: window.location.pathname,
            id: target.id || target.name || "unnamed_input",
            type: target.type || target.tagName.toLowerCase(),
            action: "change",
            value: target.type === "password" ? "[REDACTED]" : target.value,
          });
        }
      });
    }

    setupResizeTracking() {
      let resizeTimeout;

      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);

        resizeTimeout = setTimeout(() => {
          const newViewport = {
            width: window.innerWidth,
            height: window.innerHeight,
          };

          // Only track if there's a significant change
          if (
            Math.abs(newViewport.width - this.currentViewport.width) > 50 ||
            Math.abs(newViewport.height - this.currentViewport.height) > 50
          ) {
            this.track("viewport_resize", {
              semanticGroup: window.location.pathname,
              id: "viewport_change",
              type: "resize",
              action: "resize",
              value: `${newViewport.width}x${newViewport.height}`,
            });

            this.currentViewport = newViewport;
          }
        }, 300);
      });
    }

    getElementPath(element) {
      const path = [];
      while (element && element.nodeType === Node.ELEMENT_NODE) {
        let selector = element.nodeName.toLowerCase();
        if (element.id) {
          selector += "#" + element.id;
        } else if (element.className) {
          selector += "." + element.className.replace(/\s+/g, ".");
        }
        path.unshift(selector);
        element = element.parentNode;
      }
      return path.join(" > ");
    }

    generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
        /[xy]/g,
        function (c) {
          const r = (Math.random() * 16) | 0;
          const v = c === "x" ? r : (r & 0x3) | 0x8;
          return v.toString(16);
        }
      );
    }
  }

  // Global initialization function
  window.MoveoOne = {
    init: function (token, options = {}) {
      const instance = new MoveoOneWeb(token);

      // Define allowed meta fields
      const allowedMetaFields = ["locale", "test", "softwareVersion"];

      // Validate and set only allowed meta values
      Object.keys(options).forEach((key) => {
        if (allowedMetaFields.includes(key)) {
          switch (key) {
            case "locale":
              if (typeof options[key] === "string") {
                instance.meta.locale = options[key];
              }
              break;
            case "test":
              if (typeof options[key] === "string") {
                instance.meta.test = options[key];
              }
              break;
            case "softwareVersion":
              if (typeof options[key] === "string") {
                instance.meta.softwareVersion = options[key];
              }
              break;
          }
        } else {
          console.warn(
            `MoveoOne: Invalid meta field "${key}" ignored. Allowed fields: ${allowedMetaFields.join(
              ", "
            )}`
          );
        }
      });

      instance.initialize();

      // Store instance globally for access
      window.MoveoOne.instance = instance;

      return instance;
    },
  };
})(window);
