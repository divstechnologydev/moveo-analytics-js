(function (window) {
  // Prevent multiple initializations
  if (window.MoveoOne) return;

  const API_URL = "https://api.moveo.one/api/analytic/event";

  /**
   * Core MoveoOne Web Tracker
   */
  class MoveoOneWeb {
    constructor(token) {
      this.token = token;
      this.userId = "";
      this.buffer = [];
      this.flushInterval = 5000;
      this.maxThreshold = 500;
      this.context = "WEB_STATIC";

      // Use persistent session ID across page loads
      this.sessionId = this.getOrCreateSessionId();
      this.started = false;
      this.pendingUpdates = []; // Queue for updates before session starts

      // Predefined meta fields (optional, no defaults)
      this.meta = {};

      // Additional metadata - flexible key-value pairs
      this.additionalMetadata = {};

      // Track viewport size for resize events
      this.currentViewport = {
        width: window.innerWidth,
        height: window.innerHeight,
      };

      // Check if this is a page navigation within existing session
      this.isPageNavigation = this.checkIfPageNavigation();

      // Start flush interval
      setInterval(() => this.flush(), this.flushInterval);
    }

    // Get existing session ID or create new one
    getOrCreateSessionId() {
      const storageKey = "moveo-session-id";
      const timestampKey = "moveo-session-timestamp";
      const sessionTimeout = 30 * 60 * 1000; // 30 minutes in milliseconds

      const existingSessionId = localStorage.getItem(storageKey);
      const sessionTimestamp = localStorage.getItem(timestampKey);

      // Check if existing session is still valid
      if (existingSessionId && sessionTimestamp) {
        const now = Date.now();
        const lastActivity = parseInt(sessionTimestamp, 10);

        if (now - lastActivity < sessionTimeout) {
          // Update timestamp for current activity
          localStorage.setItem(timestampKey, now.toString());
          return existingSessionId;
        }
      }

      // Create new session
      const newSessionId = this.generateUUID();
      localStorage.setItem(storageKey, newSessionId);
      localStorage.setItem(timestampKey, Date.now().toString());

      return newSessionId;
    }

    // Check if this is a page navigation within an existing session
    checkIfPageNavigation() {
      const lastPathKey = "moveo-last-path";
      const lastPath = localStorage.getItem(lastPathKey);
      const currentPath = window.location.pathname;

      // Store current path for next page load
      localStorage.setItem(lastPathKey, currentPath);

      // If we have a last path and it's different from current, it's navigation
      return lastPath && lastPath !== currentPath;
    }

    // Update session timestamp on activity
    updateSessionActivity() {
      const timestampKey = "moveo-session-timestamp";
      localStorage.setItem(timestampKey, Date.now().toString());
    }

    initialize() {
      // Start session asynchronously without blocking
      this.start();

      // Setup event listeners immediately
      this.setupClickTracking();
      this.setupScrollTracking();
      this.setupFormTracking();
      this.setupResizeTracking();
      this.setupPageUnloadTracking();
      this.setupMediaTracking();
    }

    identify(userId) {
      this.userId = userId;
    }

    // Methods to update predefined meta fields (only locale, test, softwareVersion)
    setLocale(locale) {
      this.meta.locale = locale;
      this.queueOrSendUpdate("meta");
    }

    setTest(test) {
      this.meta.test = test;
      this.queueOrSendUpdate("meta");
    }

    setSoftwareVersion(version) {
      this.meta.softwareVersion = version;
      this.queueOrSendUpdate("meta");
    }

    // Helper method to queue updates before session starts or send immediately
    queueOrSendUpdate(type) {
      if (this.started) {
        // Session already started, send update immediately
        if (type === "meta") {
          this.addUpdateMetadataEvent();
        } else if (type === "additional") {
          this.addUpdateAdditionalMetadataEvent();
        }
      } else {
        // Session not started yet, queue the update
        this.pendingUpdates.push(type);
      }
    }

    // Process all pending updates after session starts
    processPendingUpdates() {
      const uniqueUpdates = [...new Set(this.pendingUpdates)]; // Remove duplicates

      uniqueUpdates.forEach((type) => {
        if (type === "meta") {
          this.addUpdateMetadataEvent();
        } else if (type === "additional") {
          this.addUpdateAdditionalMetadataEvent();
        }
      });

      this.pendingUpdates = []; // Clear the queue
    }

    // Helper method to add update_metadata event to buffer
    addUpdateMetadataEvent() {
      const event = {
        c: this.context,
        type: "update_metadata",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      this.buffer.push(event);
      this.flushOrRecord(false);
    }

    // Method to update additional metadata (flexible key-value)
    updateAdditionalMetadata(additionalData) {
      this.additionalMetadata = {
        ...this.additionalMetadata,
        ...additionalData,
      };

      this.queueOrSendUpdate("additional");
    }

    // Helper method to add update_additional_metadata event to buffer
    addUpdateAdditionalMetadataEvent() {
      const event = {
        c: this.context,
        type: "update_additional_metadata",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      this.buffer.push(event);
      this.flushOrRecord(false);
    }

    // Legacy method - now only updates additionalMetadata
    updateMetadata(metadata) {
      this.updateAdditionalMetadata(metadata);
    }

    // Helper method
    flushOrRecord(force = false) {
      if (force || this.buffer.length >= this.maxThreshold) {
        this.flush();
      }
    }

    track(type, data) {
      // Update session activity on any tracking event
      this.updateSessionActivity();

      const event = {
        c: this.context,
        type: "track",
        userId: this.userId,
        t: Date.now(),
        prop: {
          sg: window.location.pathname || "unknown",
          eID: data.id,
          eA: data.action,
          eT: data.type,
          eV: data.value || "",
        },
        meta: Object.keys(this.meta).length > 0 ? { ...this.meta } : {},
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      // Merge any event-specific metadata into additionalMetadata
      if (data.metadata) {
        event.additionalMetadata = {
          ...event.additionalMetadata,
          ...data.metadata,
        };
      }

      this.buffer.push(event);

      if (this.buffer.length >= this.maxThreshold) {
        this.flush();
      }
    }

    enrichWithGeolocation() {
      return fetch("https://ipapi.co/json/")
        .then((response) => response.json())
        .then((location) => ({
          // only the country name, as a string
          location: location.country_name || "",
        }))
        .catch((err) => {
          console.warn("MoveoOne: Failed to enrich geolocation", err);
          return { location: "" };
        });
    }

    async start() {
      // If this is a page navigation, send page_navigation event instead of start_session
      if (this.isPageNavigation) {
        await this.trackPageNavigation();
        this.started = true;
        this.processPendingUpdates();
        return;
      }

      // This is a new session
      const event = {
        c: this.context,
        type: "start_session",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      // Extract UTM parameters
      const params = new URLSearchParams(window.location.search);
      const utmParams = {
        utm_source: params.get("utm_source") || "",
        utm_medium: params.get("utm_medium") || "",
        utm_campaign: params.get("utm_campaign") || "",
        utm_term: params.get("utm_term") || "",
        utm_content: params.get("utm_content") || "",
      };

      // Check returning visitor status and add to additionalMetadata
      const isReturning = localStorage.getItem("moveo-returning") === "true";

      if (!isReturning) {
        localStorage.setItem("moveo-returning", "true");
      }

      // All session data goes to additionalMetadata
      const sessionData = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language || navigator.userLanguage,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        referrer: document.referrer || "",
        returningVisitor: isReturning,
      };

      // Screen and viewport information
      const screenData = {
        screenWidth: window.screen.width,
        screenHeight: window.screen.height,
        screenColorDepth: window.screen.colorDepth,
        viewportWidth: window.innerWidth,
        viewportHeight: window.innerHeight,
        devicePixelRatio: window.devicePixelRatio || 1,
      };

      // Get geolocation data asynchronously (this is the slow part)
      const geoData = await this.enrichWithGeolocation();

      // Add all additional data to additionalMetadata
      event.additionalMetadata = {
        ...event.additionalMetadata,
        ...utmParams,
        ...sessionData,
        ...screenData,
        ...geoData,
        url: window.location.href,
        title: document.title,
      };

      // Update instance additionalMetadata
      this.additionalMetadata = {
        ...this.additionalMetadata,
        ...event.additionalMetadata,
      };

      this.buffer.push(event);
      this.started = true; // Set started to true after adding start_session event

      // Process any pending updates that were queued before session started
      this.processPendingUpdates();

      this.flush();

      // Track initial page view
      this.track("page_view", {
        semanticGroup: window.location.pathname || "unknown",
        id: window.location.pathname,
        type: "page",
        action: "view",
        value: document.title,
      });
    }

    async trackPageNavigation() {
      // Track page navigation event
      // const event = {
      //   c: this.context,
      //   type: "track",
      //   userId: this.userId,
      //   t: Date.now(),
      //   prop: {},
      //   meta: { ...this.meta },
      //   additionalMetadata: {
      //     ...this.additionalMetadata,
      //     url: window.location.href,
      //     title: document.title,
      //     referrer: document.referrer || "",
      //   },
      //   sId: this.sessionId,
      // };

      // this.buffer.push(event);
      // this.flush();

      // Track page view for the new page
      this.track("page_view", {
        semanticGroup: window.location.pathname || "unknown",
        id: window.location.pathname,
        type: "page",
        action: "view",
        value: document.title,
      });
    }

    setupPageUnloadTracking() {
      // Track when user leaves the page
      window.addEventListener("beforeunload", () => {
        // Send any remaining events immediately
        if (this.buffer.length > 0) {
          // Use sendBeacon for more reliable delivery during page unload
          if (navigator.sendBeacon) {
            const data = JSON.stringify({ events: [...this.buffer] });
            navigator.sendBeacon(API_URL, data);
          } else {
            this.flush();
          }
        }

        // Update session timestamp
        this.updateSessionActivity();
      });

      // Also track page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          this.updateSessionActivity();
          // Flush any pending events when page becomes hidden
          if (this.buffer.length > 0) {
            this.flush();
          }
        }
      });
    }

    setupMediaTracking() {
      // Track existing media elements
      const trackMediaElements = () => {
        const mediaElements = document.querySelectorAll("video, audio");

        mediaElements.forEach((media) => {
          // Avoid duplicate listeners by checking if already tracked
          if (media.dataset.moveoTracked) return;
          media.dataset.moveoTracked = "true";

          const mediaType = media.tagName.toLowerCase();
          const mediaId =
            media.id || media.currentSrc || media.src || "unnamed_media";

          media.addEventListener("play", () => {
            this.track("media_play", {
              semanticGroup: "media",
              id: mediaId,
              type: mediaType,
              action: "play",
              metadata: {
                duration: media.duration || 0,
                currentTime: media.currentTime || 0,
                src: media.currentSrc || media.src || "",
                volume: media.volume || 1,
              },
            });
          });

          media.addEventListener("pause", () => {
            this.track("media_pause", {
              semanticGroup: "media",
              id: mediaId,
              type: mediaType,
              action: "pause",
              metadata: {
                duration: media.duration || 0,
                currentTime: media.currentTime || 0,
                src: media.currentSrc || media.src || "",
                volume: media.volume || 1,
              },
            });
          });

          media.addEventListener("ended", () => {
            this.track("media_complete", {
              semanticGroup: "media",
              id: mediaId,
              type: mediaType,
              action: "complete",
              metadata: {
                duration: media.duration || 0,
                currentTime: media.currentTime || 0,
                src: media.currentSrc || media.src || "",
                volume: media.volume || 1,
              },
            });
          });
        });
      };

      // Track media elements on initial load
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", trackMediaElements);
      } else {
        trackMediaElements();
      }

      // Watch for dynamically added media elements
      // Only set up observer if document.body exists, otherwise wait for DOM ready
      const setupObserver = () => {
        const targetNode = document.body || document.documentElement;
        if (targetNode) {
          const observer = new MutationObserver(() => {
            trackMediaElements();
          });

          observer.observe(targetNode, {
            childList: true,
            subtree: true,
          });
        }
      };

      if (document.body) {
        setupObserver();
      } else {
        document.addEventListener("DOMContentLoaded", setupObserver);
      }
    }

    flush() {
      if (this.buffer.length === 0) return;

      const dataToSend = [...this.buffer];
      this.buffer = [];

      // Debug logging
      console.log("MoveoOne: Sending events", dataToSend);
      dataToSend.forEach((event, index) => {
        console.log(`Event ${index}:`, {
          type: event.type,
          context: event.c,
          sessionId: event.sId,
          meta: event.meta,
          additionalMetadata: event.additionalMetadata,
        });
      });

      fetch(API_URL, {
        method: "POST",
        headers: {
          Authorization: this.token,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ events: dataToSend }),
      }).catch((error) => console.error("MoveoOne Error:", error));
    }

    setupClickTracking() {
      document.addEventListener("click", (event) => {
        let target = event.target;
        let elementType = target.tagName.toLowerCase();

        // Find closest clickable parent if target itself isn't clickable
        if (!["a", "button", "input", "select"].includes(elementType)) {
          target = target.closest(
            'a, button, input[type="button"], input[type="submit"], select'
          );
          if (!target) return;
          elementType = target.tagName.toLowerCase();
        }

        const data = {
          semanticGroup: window.location.pathname,
          id: target.id || target.name || target.href || "unnamed_element",
          type: elementType,
          action: "click",
          value: target.textContent?.trim() || target.value || "",
          metadata: {
            path: this.getElementPath(target),
            href: target.href || "",
            className: target.className || "",
            coordinates: `${event.clientX},${event.clientY}`,
          },
        };

        this.track("click", data);
      });
    }

    setupScrollTracking() {
      let lastScrollPosition = 0;
      let scrollTimeout;

      window.addEventListener("scroll", () => {
        clearTimeout(scrollTimeout);

        scrollTimeout = setTimeout(() => {
          const scrollPosition = window.scrollY;
          const documentHeight =
            document.documentElement.scrollHeight - window.innerHeight;
          const scrollPercentage = Math.round(
            (scrollPosition / documentHeight) * 100
          );

          if (Math.abs(scrollPosition - lastScrollPosition) > 100) {
            this.track("scroll", {
              semanticGroup: window.location.pathname,
              id: "page_scroll",
              type: "scroll",
              action: "scroll",
              value: scrollPercentage.toString(),
              metadata: {
                position: scrollPosition,
                percentage: scrollPercentage,
                documentHeight: documentHeight + window.innerHeight,
              },
            });

            lastScrollPosition = scrollPosition;
          }
        }, 500);
      });
    }

    setupFormTracking() {
      document.addEventListener("submit", (event) => {
        const form = event.target;

        this.track("form_submit", {
          semanticGroup: window.location.pathname,
          id: form.id || form.name || "unnamed_form",
          type: "form",
          action: "submit",
          value: "",
          metadata: {
            path: this.getElementPath(form),
            method: form.method || "get",
            action: form.action || "",
          },
        });
      });

      document.addEventListener("change", (event) => {
        const target = event.target;
        if (
          ["select", "input", "textarea"].includes(target.tagName.toLowerCase())
        ) {
          this.track("form_change", {
            semanticGroup: window.location.pathname,
            id: target.id || target.name || "unnamed_input",
            type: target.type || target.tagName.toLowerCase(),
            action: "change",
            value: target.type === "password" ? "[REDACTED]" : target.value,
            metadata: {
              path: this.getElementPath(target),
              fieldType: target.type || target.tagName.toLowerCase(),
            },
          });
        }
      });
    }

    setupResizeTracking() {
      let resizeTimeout;

      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);

        resizeTimeout = setTimeout(() => {
          const newViewport = {
            width: window.innerWidth,
            height: window.innerHeight,
          };

          // Only track if there's a significant change
          if (
            Math.abs(newViewport.width - this.currentViewport.width) > 50 ||
            Math.abs(newViewport.height - this.currentViewport.height) > 50
          ) {
            this.track("viewport_resize", {
              semanticGroup: window.location.pathname,
              id: "viewport_change",
              type: "resize",
              action: "resize",
              value: `${newViewport.width}x${newViewport.height}`,
              metadata: {
                oldSize: `${this.currentViewport.width}x${this.currentViewport.height}`,
                newSize: `${newViewport.width}x${newViewport.height}`,
                widthChange: newViewport.width - this.currentViewport.width,
                heightChange: newViewport.height - this.currentViewport.height,
              },
            });

            this.currentViewport = newViewport;
          }
        }, 300);
      });
    }

    getElementPath(element) {
      const path = [];
      while (element && element.nodeType === Node.ELEMENT_NODE) {
        let selector = element.nodeName.toLowerCase();
        if (element.id) {
          selector += "#" + element.id;
        } else if (element.className) {
          selector += "." + element.className.replace(/\s+/g, ".");
        }
        path.unshift(selector);
        element = element.parentNode;
      }
      return path.join(" > ");
    }

    generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
        /[xy]/g,
        function (c) {
          const r = (Math.random() * 16) | 0;
          const v = c === "x" ? r : (r & 0x3) | 0x8;
          return v.toString(16);
        }
      );
    }
  }

  // Global initialization function
  window.MoveoOne = {
    init: function (token, options = {}) {
      const instance = new MoveoOneWeb(token);

      // Define allowed meta fields
      const allowedMetaFields = ["locale", "test", "softwareVersion"];

      // Validate and set only allowed meta values
      Object.keys(options).forEach((key) => {
        if (allowedMetaFields.includes(key)) {
          switch (key) {
            case "locale":
              if (typeof options[key] === "string") {
                instance.meta.locale = options[key];
              }
              break;
            case "test":
              if (typeof options[key] === "string") {
                instance.meta.test = options[key];
              }
              break;
            case "softwareVersion":
              if (typeof options[key] === "string") {
                instance.meta.softwareVersion = options[key];
              }
              break;
          }
        } else {
          console.warn(
            `MoveoOne: Invalid meta field "${key}" ignored. Allowed fields: ${allowedMetaFields.join(
              ", "
            )}`
          );
        }
      });

      instance.initialize();

      // Store instance globally for access
      window.MoveoOne.instance = instance;

      return instance;
    },
  };
})(window);
