(function (window) {
  // Prevent multiple initializations
  if (window.MoveoOne) return;

  const API_URL = "https://api.moveo.one/api/analytic/event";

  /**
   * Core MoveoOne Web Tracker
   */
  class MoveoOneWeb {
    constructor(token) {
      this.token = token;
      this.userId = "";
      this.buffer = [];
      this.flushInterval = 10000;
      this.maxThreshold = 500;
      this.context = window.location.pathname;
      this.sessionId = this.generateUUID();
      this.started = false;
      this.pendingUpdates = []; // Queue for updates before session starts

      // Predefined meta fields (optional, no defaults)
      this.meta = {};

      // Additional metadata - flexible key-value pairs
      this.additionalMetadata = {};

      // Track viewport size for resize events
      this.currentViewport = {
        width: window.innerWidth,
        height: window.innerHeight,
      };

      // Start flush interval
      setInterval(() => this.flush(), this.flushInterval);
    }

    initialize() {
      // Start session asynchronously without blocking
      this.start();

      // Setup event listeners immediately
      this.setupClickTracking();
      this.setupScrollTracking();
      this.setupFormTracking();
      this.setupResizeTracking();
    }

    identify(userId) {
      this.userId = userId;
    }

    // Methods to update predefined meta fields (only locale, test, softwareVersion)
    setLocale(locale) {
      this.meta.locale = locale;
      this.queueOrSendUpdate("meta");
    }

    setTest(test) {
      this.meta.test = test;
      this.queueOrSendUpdate("meta");
    }

    setSoftwareVersion(version) {
      this.meta.softwareVersion = version;
      this.queueOrSendUpdate("meta");
    }

    // Helper method to queue updates before session starts or send immediately
    queueOrSendUpdate(type) {
      if (this.started) {
        // Session already started, send update immediately
        if (type === "meta") {
          this.addUpdateMetadataEvent();
        } else if (type === "additional") {
          this.addUpdateAdditionalMetadataEvent();
        }
      } else {
        // Session not started yet, queue the update
        this.pendingUpdates.push(type);
      }
    }

    // Process all pending updates after session starts
    processPendingUpdates() {
      const uniqueUpdates = [...new Set(this.pendingUpdates)]; // Remove duplicates

      uniqueUpdates.forEach((type) => {
        if (type === "meta") {
          this.addUpdateMetadataEvent();
        } else if (type === "additional") {
          this.addUpdateAdditionalMetadataEvent();
        }
      });

      this.pendingUpdates = []; // Clear the queue
    }

    // Helper method to add update_metadata event to buffer
    addUpdateMetadataEvent() {
      const event = {
        c: this.context,
        type: "update_metadata",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      this.buffer.push(event);
      this.flushOrRecord(false);
    }

    // Method to update additional metadata (flexible key-value)
    updateAdditionalMetadata(additionalData) {
      this.additionalMetadata = {
        ...this.additionalMetadata,
        ...additionalData,
      };

      this.queueOrSendUpdate("additional");
    }

    // Helper method to add update_additional_metadata event to buffer
    addUpdateAdditionalMetadataEvent() {
      const event = {
        c: this.context,
        type: "update_additional_metadata",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      this.buffer.push(event);
      this.flushOrRecord(false);
    }

    // Legacy method - now only updates additionalMetadata
    updateMetadata(metadata) {
      this.updateAdditionalMetadata(metadata);
    }

    // Helper method
    flushOrRecord(force = false) {
      if (force || this.buffer.length >= this.maxThreshold) {
        this.flush();
      }
    }

    track(type, data) {
      const event = {
        c: this.context,
        type: "track",
        userId: this.userId,
        t: Date.now(),
        prop: {
          sg: data.semanticGroup,
          eID: data.id,
          eA: data.action,
          eT: data.type,
          eV: data.value || "",
        },
        meta: Object.keys(this.meta).length > 0 ? { ...this.meta } : {},
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      // Merge any event-specific metadata into additionalMetadata
      if (data.metadata) {
        event.additionalMetadata = {
          ...event.additionalMetadata,
          ...data.metadata,
        };
      }

      this.buffer.push(event);

      if (this.buffer.length >= this.maxThreshold) {
        this.flush();
      }
    }

    enrichWithGeolocation() {
      return fetch("https://ipapi.co/json/")
        .then((response) => response.json())
        .then((location) => ({
          // only the country name, as a string
          location: location.country_name || "",
        }))
        .catch((err) => {
          console.warn("MoveoOne: Failed to enrich geolocation", err);
          return { location: "" };
        });
    }

    async start() {
      const event = {
        c: this.context,
        type: "start_session",
        userId: this.userId,
        t: Date.now(),
        prop: {},
        meta: { ...this.meta },
        additionalMetadata: { ...this.additionalMetadata },
        sId: this.sessionId,
      };

      // Extract UTM parameters
      const params = new URLSearchParams(window.location.search);
      const utmParams = {
        utm_source: params.get("utm_source") || "",
        utm_medium: params.get("utm_medium") || "",
        utm_campaign: params.get("utm_campaign") || "",
        utm_term: params.get("utm_term") || "",
        utm_content: params.get("utm_content") || "",
      };

      // Check returning visitor status and add to additionalMetadata
      const isReturning = localStorage.getItem("moveo-returning") === "true";

      if (!isReturning) {
        localStorage.setItem("moveo-returning", "true");
      }

      // All session data goes to additionalMetadata
      const sessionData = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language || navigator.userLanguage,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        referrer: document.referrer || "",
        returningVisitor: isReturning,
      };

      // Screen and viewport information
      const screenData = {
        screenWidth: window.screen.width,
        screenHeight: window.screen.height,
        screenColorDepth: window.screen.colorDepth,
        viewportWidth: window.innerWidth,
        viewportHeight: window.innerHeight,
        devicePixelRatio: window.devicePixelRatio || 1,
      };

      // Get geolocation data asynchronously (this is the slow part)
      const geoData = await this.enrichWithGeolocation();

      // Add all additional data to additionalMetadata
      event.additionalMetadata = {
        ...event.additionalMetadata,
        ...utmParams,
        ...sessionData,
        ...screenData,
        ...geoData,
        url: window.location.href,
        title: document.title,
      };

      // Update instance additionalMetadata
      this.additionalMetadata = {
        ...this.additionalMetadata,
        ...event.additionalMetadata,
      };

      this.buffer.push(event);
      this.started = true; // Set started to true after adding start_session event

      // Process any pending updates that were queued before session started
      this.processPendingUpdates();

      this.flush();

      this.track("page_view", {
        semanticGroup: "navigation",
        id: window.location.pathname,
        type: "page",
        action: "view",
        value: document.title,
      });
    }

    flush() {
      if (this.buffer.length === 0) return;

      const dataToSend = [...this.buffer];
      this.buffer = [];

      // Debug logging
      console.log("MoveoOne: Sending events", dataToSend);
      dataToSend.forEach((event, index) => {
        console.log(`Event ${index}:`, {
          type: event.type,
          meta: event.meta,
          additionalMetadata: event.additionalMetadata,
        });
      });

      fetch(API_URL, {
        method: "POST",
        headers: {
          Authorization: this.token,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ events: dataToSend }),
      }).catch((error) => console.error("MoveoOne Error:", error));
    }

    setupClickTracking() {
      document.addEventListener("click", (event) => {
        let target = event.target;
        let elementType = target.tagName.toLowerCase();

        // Find closest clickable parent if target itself isn't clickable
        if (!["a", "button", "input", "select"].includes(elementType)) {
          target = target.closest(
            'a, button, input[type="button"], input[type="submit"], select'
          );
          if (!target) return;
          elementType = target.tagName.toLowerCase();
        }

        const data = {
          semanticGroup: "interaction",
          id: target.id || target.name || target.href || "unnamed_element",
          type: elementType,
          action: "click",
          value: target.textContent?.trim() || target.value || "",
          metadata: {
            path: this.getElementPath(target),
            href: target.href || "",
            className: target.className || "",
            coordinates: `${event.clientX},${event.clientY}`,
          },
        };

        this.track("click", data);
      });
    }

    setupScrollTracking() {
      let lastScrollPosition = 0;
      let scrollTimeout;

      window.addEventListener("scroll", () => {
        clearTimeout(scrollTimeout);

        scrollTimeout = setTimeout(() => {
          const scrollPosition = window.scrollY;
          const documentHeight =
            document.documentElement.scrollHeight - window.innerHeight;
          const scrollPercentage = Math.round(
            (scrollPosition / documentHeight) * 100
          );

          if (Math.abs(scrollPosition - lastScrollPosition) > 100) {
            this.track("scroll", {
              semanticGroup: "interaction",
              id: "page_scroll",
              type: "scroll",
              action: "scroll",
              value: scrollPercentage.toString(),
              metadata: {
                position: scrollPosition,
                percentage: scrollPercentage,
                documentHeight: documentHeight + window.innerHeight,
              },
            });

            lastScrollPosition = scrollPosition;
          }
        }, 500);
      });
    }

    setupFormTracking() {
      document.addEventListener("submit", (event) => {
        const form = event.target;

        this.track("form_submit", {
          semanticGroup: "interaction",
          id: form.id || form.name || "unnamed_form",
          type: "form",
          action: "submit",
          value: "",
          metadata: {
            path: this.getElementPath(form),
            method: form.method || "get",
            action: form.action || "",
          },
        });
      });

      document.addEventListener("change", (event) => {
        const target = event.target;
        if (
          ["select", "input", "textarea"].includes(target.tagName.toLowerCase())
        ) {
          this.track("form_change", {
            semanticGroup: "interaction",
            id: target.id || target.name || "unnamed_input",
            type: target.type || target.tagName.toLowerCase(),
            action: "change",
            value: target.type === "password" ? "[REDACTED]" : target.value,
            metadata: {
              path: this.getElementPath(target),
              fieldType: target.type || target.tagName.toLowerCase(),
            },
          });
        }
      });
    }

    setupResizeTracking() {
      let resizeTimeout;

      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);

        resizeTimeout = setTimeout(() => {
          const newViewport = {
            width: window.innerWidth,
            height: window.innerHeight,
          };

          // Only track if there's a significant change
          if (
            Math.abs(newViewport.width - this.currentViewport.width) > 50 ||
            Math.abs(newViewport.height - this.currentViewport.height) > 50
          ) {
            this.track("viewport_resize", {
              semanticGroup: "interaction",
              id: "viewport_change",
              type: "resize",
              action: "resize",
              value: `${newViewport.width}x${newViewport.height}`,
              metadata: {
                oldSize: `${this.currentViewport.width}x${this.currentViewport.height}`,
                newSize: `${newViewport.width}x${newViewport.height}`,
                widthChange: newViewport.width - this.currentViewport.width,
                heightChange: newViewport.height - this.currentViewport.height,
              },
            });

            this.currentViewport = newViewport;
          }
        }, 300);
      });
    }

    getElementPath(element) {
      const path = [];
      while (element && element.nodeType === Node.ELEMENT_NODE) {
        let selector = element.nodeName.toLowerCase();
        if (element.id) {
          selector += "#" + element.id;
        } else if (element.className) {
          selector += "." + element.className.replace(/\s+/g, ".");
        }
        path.unshift(selector);
        element = element.parentNode;
      }
      return path.join(" > ");
    }

    generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
        /[xy]/g,
        function (c) {
          const r = (Math.random() * 16) | 0;
          const v = c === "x" ? r : (r & 0x3) | 0x8;
          return v.toString(16);
        }
      );
    }
  }

  // Global initialization function
  window.MoveoOne = {
    init: function (token, options = {}) {
      const instance = new MoveoOneWeb(token);

      // Define allowed meta fields
      const allowedMetaFields = ["locale", "test", "softwareVersion"];

      // Validate and set only allowed meta values
      Object.keys(options).forEach((key) => {
        if (allowedMetaFields.includes(key)) {
          switch (key) {
            case "locale":
              if (typeof options[key] === "string") {
                instance.meta.locale = options[key];
              }
              break;
            case "test":
              if (typeof options[key] === "string") {
                instance.meta.test = options[key];
              }
              break;
            case "softwareVersion":
              if (typeof options[key] === "string") {
                instance.meta.softwareVersion = options[key];
              }
              break;
          }
        } else {
          console.warn(
            `MoveoOne: Invalid meta field "${key}" ignored. Allowed fields: ${allowedMetaFields.join(
              ", "
            )}`
          );
        }
      });

      instance.initialize();

      // Store instance globally for access
      window.MoveoOne.instance = instance;

      return instance;
    },
  };
})(window);
